#!/usr/bin/python3

import sys
import os.path
import re
import socket
import select
import ssl
import getopt
import traceback
import threading
import signal
import logging
import struct
import binascii
import sqlite3

from cryptography import x509
from cryptography.hazmat import backends
from cryptography.hazmat.primitives import hashes


PROTOCOL_ID = 87
PROTOCOL_VERSION = 1

COMMAND_NONE = 0
COMMAND_VERIFY_REQUEST = 1
COMMAND_VERIFY_RESPONSE = 2
COMMAND_QUERY_REQUEST = 3
COMMAND_QUERY_RESPONSE = 4

ELEMENT_DEVICE_NAME = 1
ELEMENT_CERTIFICATE = 2
ELEMENT_STATUS = 7
ELEMENT_ROLES = 8
ELEMENT_TTL = 9

STATUS_VALID = 0
STATUS_INVALID = 1

ROLE_SAST = 0
ROLE_CCM = 1
ROLE_CCM_TFTP = 2
ROLE_TFTP = 3
ROLE_CAPF = 4
ROLE_APP_SERVER = 7
ROLE_TVS = 21


database_file = None
default_ttl = 86400


threading.main_thread().name = 'main-thread'
logging.basicConfig(level = logging.DEBUG, format = '%(threadName)s %(message)s', stream = sys.stdout, force = True)


class ProgramError(Exception):
    pass


def send_response(client_socket, command, session_id, elements):
    response = bytearray()
    response += struct.pack('> B B B B I H', PROTOCOL_ID, PROTOCOL_VERSION, command, 0, session_id, 0)

    for tag, value in elements.items():
        if tag == ELEMENT_STATUS:
            status = value
            response += struct.pack('> B H B', ELEMENT_STATUS, 1, status)

        elif tag == ELEMENT_ROLES:
            roles = value

            response += struct.pack('> B H', ELEMENT_ROLES, len(roles))
            response += roles

        elif tag == ELEMENT_TTL:
            ttl = value
            response += struct.pack('> B H I', ELEMENT_TTL, 4, ttl)

        else:
            raise ProgramError(f'Unknown ELEMENT tag: {tag}')

    struct.pack_into('> H', response, 8, len(response) - 10)
    client_socket.send(response)


def receive_request(client_socket, client_session_id):
    request = client_socket.recv(10)

    if not len(request):
        raise ProgramError('Client closed socket')

    if len(request) != 10:
        raise ProgramError('Invalid header length')

    (protocol_id, version, command, session_id, length) = struct.unpack_from('> B B B x I H', request, 0)

    if protocol_id != PROTOCOL_ID:
        raise ProgramError(f'Invalid protocol ID: {protocol_id}')

    if version != PROTOCOL_VERSION:
        raise ProgramError(f'Invalid protocol version: {version}')

    if client_session_id is not None and session_id != client_session_id:
        raise ProgramError(f'Unexpected session ID: {session_id}')

    while len(request) < (length + 10):
        request += client_socket.recv((length + 10) - len(request))

    elements = {}
    index = 10

    while index < len(request):
        (tag, length) = struct.unpack_from('> B H', request, index)
        index += 3

        if tag == ELEMENT_DEVICE_NAME:
            device_name = request[index:index + length]
            device_name = device_name[1:].decode('utf-8')

            elements[ELEMENT_DEVICE_NAME] = device_name

        elif tag == ELEMENT_CERTIFICATE:
            certificate = request[index:index + length]
            elements[ELEMENT_CERTIFICATE] = certificate

        else:
            raise ProgramError(f'Unknown ELEMENT tag: {tag}')

        index += length

    return command, session_id, elements


def verify_certificate(client_socket, session_id, elements, database):
    device_name = elements.get(ELEMENT_DEVICE_NAME, None)

    if device_name is None:
        raise ProgramError('No device name')

    if not re.search(r'(?x) ^ CP - [0-9]{4} - SEP [0-9A-F]{12} $', device_name):
        raise ProgramError(f'Invalid device name: {device_name}')

    logging.info('Device Name: %s', device_name)

    certificate = elements.get(ELEMENT_CERTIFICATE, None)

    if certificate is None:
        raise ProgramError('Missing ELEMENT_CERTIFICATE')

    try:
        certificate = x509.load_der_x509_certificate(certificate, backends.default_backend())
    except ValueError:
        raise ProgramError('Invalid certificate')

    serial_number = serial_number = certificate.serial_number
    serial_number = serial_number.to_bytes((serial_number.bit_length() + 7) // 8, byteorder = 'big')
    serial_number = binascii.hexlify(serial_number).decode('utf-8')

    logging.info('Serial Number: %s', serial_number)

    subject_name = ''

    for attribute in certificate.subject:
        subject_name += (';' if len(subject_name) else '') + attribute.rfc4514_string()

    logging.info('Subject Name: %s', subject_name)

    issuer_name = ''

    for attribute in certificate.issuer:
        issuer_name += (';' if len(issuer_name) else '') + attribute.rfc4514_string()

    logging.info('Issuer Name: %s', issuer_name)

    certificate_hash = certificate.fingerprint(hashes.SHA256())
    certificate_hash = binascii.hexlify(certificate_hash).decode('utf-8')

    logging.info('Certificate Hash: %s', certificate_hash)

    global default_ttl

    cursor = database.cursor()

    cursor.execute('SELECT roles, coalesce(ttl, ?) AS ttl FROM certificates WHERE certificate_hash = ?',
                   (default_ttl, certificate_hash))

    row = cursor.fetchone()

    if row is not None:
        logging.info('Status: Valid')
        logging.info('Roles: %s', row['roles'])
        logging.info('TTL: %d', row['ttl'])

        roles = bytearray()

        for role in row['roles'].split(','):
            if role == 'SAST':
                roles.append(ROLE_SAST)
            elif role == 'CCM':
                roles.append(ROLE_CCM)
            elif role == 'CCM+TFTP':
                roles.append(ROLE_CCM_TFTP)
            elif role == 'TFTP':
                roles.append(ROLE_TFTP)
            elif role == 'CAPF':
                roles.append(ROLE_CAPF)
            elif role == 'APP-SERVER':
                roles.append(ROLE_APP_SERVER)
            elif role == 'TVS':
                roles.append(ROLE_TVS)

        ttl = row['ttl']

        send_response(client_socket, COMMAND_VERIFY_RESPONSE, session_id, {
            ELEMENT_STATUS: STATUS_VALID,
            ELEMENT_ROLES: roles,
            ELEMENT_TTL: ttl
        })

    else:
        logging.info('Status: Invalid')

        send_response(client_socket, COMMAND_VERIFY_RESPONSE, session_id, {
            ELEMENT_STATUS: STATUS_INVALID
        })


def handle_client(client_socket):
    try:
        command, session_id, elements = receive_request(client_socket, None)

        if command != COMMAND_VERIFY_REQUEST:
            raise ProgramError(f'Unexpected command: {command}')

        global database_file

        with sqlite3.connect(database_file) as database:
            database.row_factory = sqlite3.Row
            verify_certificate(client_socket, session_id, elements, database)

    except (ProgramError, sqlite3.Error) as error:
        logging.info('Error: %s', error)

    except Exception:
        logging.error('%s', traceback.format_exc())

    client_socket.close()


def start_server(port, timeout, tvs_certificate_file):
    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)

    try:
        ssl_context.load_cert_chain(tvs_certificate_file)
    except (PermissionError, FileNotFoundError, IsADirectoryError) as error:
        raise ProgramError(f'{error.strerror}: {error.filename}')

    ssl_context.verify_mode = ssl.CERT_NONE

    try:
        server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server_socket.settimeout(timeout)

        server_socket = ssl_context.wrap_socket(server_socket, server_side = True)

        server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
        server_socket.bind(('0.0.0.0', port))

        server_socket.listen(5)

    except ssl.SSLError as error:
        raise ProgramError(error.reason)

    except OSError as error:
        raise ProgramError(error)

    logging.info('Listening Port: %d', port)

    poll = select.poll()
    poll.register(server_socket.fileno(), select.POLLIN)

    for signum in signal.SIGINT, signal.SIGQUIT, signal.SIGTERM:
        signal.signal(signum, stop_server)

    try:
        while True:
            events = poll.poll(60)

            for fileno, event in events:
                if fileno != server_socket.fileno() or not event & select.POLLIN:
                    continue

                try:
                    client_socket, unused = server_socket.accept()

                except OSError as error:
                    logging.error('%s', str(error))
                    continue

                ip_address, port = client_socket.getpeername()

                thread = threading.Thread(daemon = True, name = f'{ip_address}:{port}', target = handle_client, args = (client_socket,))
                thread.start()

    except InterruptedError:
        pass

    server_socket.close()


def stop_server(signum, frame):
    raise InterruptedError


def main():
    try:
        short_options = 'p:t:T:L:H'
        long_options = ['port=', 'timeout=', 'tvs=', 'ttl=', 'help']

        try:
            options, arguments = getopt.gnu_getopt(sys.argv[1:], short_options, long_options)
        except getopt.GetoptError as error:
            raise ProgramError(error.msg[0].upper() + error.msg[1:])

        global database_file, default_ttl

        port = 2445
        timeout = 10
        tvs_certificate_file = None
        help = False

        for option, argument in options:
            if option in ('-p', '--port'):
                port = argument

                try:
                    port = int(port)

                    if port < 1 or port > 65535:
                        raise ValueError

                except ValueError:
                    raise ProgramError(f'Invalid port: {port}')

            elif option in ('-t', '--timeout'):
                timeout = argument

                try:
                    timeout = int(timeout)
                except ValueError:
                    raise ProgramError(f'Invalid timeout: {timeout}')

            elif option in ('-L', '--ttl'):
                default_ttl = argument

                try:
                    default_ttl = int(default_ttl)
                except ValueError:
                    raise ProgramError(f'Invalid default TTL: {default_ttl}')

                if default_ttl < 1 or default_ttl > 2592000:
                    raise ProgramError(f'TTL must be between 1 and 2592000')

            elif option in ('-T', '--tvs'):
                tvs_certificate_file = argument

            elif option in ('-H', '--help'):
                help = True

        if help:
            print('Usage: ' + os.path.basename(sys.argv[0]) + ' [OPTIONS] DATABASE-FILE\n'
                  'Query the validity of a certificate using a TVS server.\n'
                  '\n'
                  '  -T, --tvs TVS-CERT-FILE         TVS server certificate\n'
                  '  -p, --port PORT                 port TVS server is listening on (default 2445)\n'
                  '  -t, --timeout TIMEOUT           connection timeout in seconds (default 10)\n'
                  '  -L, --ttl LIFETIME              default response validity lifetime\n'
                  '  -H, --help                      print this help and exit\n'
                  '\n'
                  'DATABASE-FILE can be created and managed using the tvsctl program.\n')

            return

        if not len(arguments):
            raise ProgramError('No database file specified')

        database_file = arguments[0]

        if tvs_certificate_file is None:
            raise ProgramError('No TVS certificate file specified')

        start_server(port, timeout, tvs_certificate_file)

    except ProgramError as error:
        logging.error('%s', str(error))
        exit(1)

    except Exception:
        logging.error('%s', traceback.format_exc())
        exit(1)

    exit(0)


if __name__ == '__main__':
    main()
